#!/bin/bash

# Sort entry files of a directory

# Copyright (C) 2020 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 1 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,

#AUTHOR : Es-sebbani Naim, Guestin Jason, Jinhuo Li

version="trishell 1.0
Copyright (C) 2020 Free Software Foundation, Inc.
This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <https://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

Written by Es-sebbani Naim, Guestin Jason, Jinhuo Li."

usage="Usage: $0 [-R] [-nsmleptg] dir
Sort entry files (by default, ascending order).

You can use all this option

    -R,         sort the contents of the tree starting at the directory dir. In this case we will sort according to the entry names but the path will be display(ed)?,
    -d,         sorting in descending order, by default sorting is done in ascending order,
    -n,         sort according to the entry name,
    -s,         sort by entry size,
    -m,         sort according to the last modification date of the entries,
    -l,         sort according to the number of rows of entries,
    -e,         sort according to the extension of the entries (characters found after the last point of the entry name),
    -p,         sort by the name of the entry owner,
    -t,         sort according to the type of file (order: directory, file, links, block type special file, file special type character, named pipe, socket),
    -g,         sort by the name of the entry group,
    -help       display this help and exit
    -version    display version information and exit


Report bugs to <naimessebbani@gmail.com>."

case $1 in
-help)    printf '%s\n' "$usage"   || exit 1; exit;;
-version) printf '%s\n' "$version" || exit 1; exit;;
esac

if [ $# -gt 4 ]
then
    echo "Trop d'arguments"
    exit 1
fi

#INIT VAR
asc=true
display=false
sortOrder="NULL"
sortLength=0
path="NULL"

#READ ARG
for i in $*
do
    if [ $i = "-R" ]
    then
        test $display = true && echo "Doublon dans les parametres" && exit 2 
        display=true
    elif [ $i = "-d" ]
    then
        test $asc = false && echo "Doublon dans les parametres" && exit 2 
        asc=false
    elif [[ $i =~ ^[^-] ]]
    then
        ! test -d "$i" && echo "Chemin incorrect" && exit 4
        test $path != NULL && echo "Doublon dans les parametres" && exit 2 
        path=$i
    else
        test $sortOrder != NULL && echo "Doublon dans les parametres" && exit 2 
        sortOrder=$i
    fi
done

test $path = NULL && echo "Veuillez indiquer  un chemin" && exit 3

for i in $(seq 2 ${#sortOrder}); do
     char=$(echo $sortOrder | cut -c$i)
     if [[ $char =~ [^n,s,m,l,e,p,t,g] ]]
     then
        echo "Param de tri pas bon" && exit 5
    else 
        sortLength=$(($sortLength+1))
     fi
done



#START OF PROG

cd $path

allData=""
sizeOfAllData=0
for i in *
do
    allData="$i/$allData"
    sizeOfAllData=$(($sizeOfAllData+1))
done
allData=${allData%?}

#TRI RAPIDE EN C 

#void tri_rapide (int *tableau, int taille) {
#    int mur, courant, pivot, tmp;
#     if (taille < 2) return;
#     // On prend comme pivot l element le plus a droite
#     pivot = tableau[taille - 1];
#      mur  = courant = 0;
#       while (courant<taille) {
#      if (tableau[courant] <= pivot) {
#           if (mur != courant) {
#               tmp=tableau[courant];
#               tableau[courant]=tableau[mur];
#               tableau[mur]=tmp;              
#            }
#            mur ++;
#      }
#      courant ++;
#     }
#     tri_rapide(tableau, mur - 1);
#     tri_rapide(tableau + mur - 1, taille - mur + 1);
# }


doHeIsBigger(){
    #GROS SWITCH SA MERE PLUS TARD
    if test $1 \< $2 
    then
        echo 0
    else
        echo 1
    fi
}

permute(){
    #ATTENTION ERREUR AVEC LES DOUBLONS !
    local firstVal=$2
    local secondVal=$3
    IFS=/
    res=""
    for i in $1
    do
        if [[ $i = $firstVal ]]
        then
            res="$res/$secondVal"
        elif [[ $i = $secondVal ]]
        then 
            res="$res/$firstVal"
        else
            res="$res/$i"
        fi
    done
    IFS=$OLDIFS
    res="${res:1}"
    echo $res
}

fastSort(){
    [ $2 -lt 2 ] && echo "$1" && exit 1

    local tab=$1
    pivot=`echo $tab | cut -d'/' -f$2`
    mur=0
    courant=$3
    while [ $courant -lt $2 ]
    do
        currentData=`echo $tab | cut -d'/' -f$(($courant+1))`
        if [ `doHeIsBigger $curentData $pivot 0` = 1 ]
        then
            if [ $mur -ne $courant ]
            then
                #PERMUTER CURENTDATA AVEC TABLEAU[MUR]
                murData=`echo $tab | cut -d'/' -f$(($mur+1))`
                #echo "le tab est $tab permutation de $murData avec $currentData"
                tab=`permute $tab $currentData $murData`
            fi
            mur=$(($mur+1))
        fi
        courant=$(($courant+1))
    done
    fastSort $tab $(($mur-1)) 0
    fastSort $tab $(($2-$mur+1)) $(($mur+1))
}

echo $allData
fastSort $allData $sizeOfAllData 0
